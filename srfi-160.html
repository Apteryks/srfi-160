<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <meta charset="utf-8" />
    <title>SRFI 160: Homogeneous numeric vector libraries</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png" />
  </head>

  <body>

<H1>Title</H1>

Homogeneous numeric vector libraries

<H1>Author</H1>

John Cowan (based on SRFI 4 by Marc Feeley)

<H1>Status</H1>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+160+at+srfi+dotschemers+dot+org">srfi-160@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-160">archive</a>.</p>
<ul>
  <li>Received: 2018/5/20</li>
  <li>60-day deadline: 2018/7/20</li>
  <li>Draft #1 published: 2018/8/21</li>
  <li>Draft #2 published: 2018/9/2</li>
  <li>Draft #3 published: 2018/9/8</li>
  <li>Draft #4 published: 2018/10/10</li>
  <li>Draft #5 published: 2018/10/30</li>
</ul>

<H1>Abstract</H1>

This SRFI describes a set of datatypes for vectors whose elements are
of the same numeric type (signed or unsigned exact integer or inexact
number of a given precision).  These datatypes support operations
analogous to the Scheme vector type, but they are distinct datatypes.
An external representation is specified which may be supported by the
<code>read</code> and <code>write</code> procedures and by the program
parser (i.e. programs can contain references to literal homogeneous
vectors).

<H1>Issues</H1>

<ul>
  <li>None at present.</li>

</ul>

<H1>Rationale</H1>

Like lists, Scheme vectors are a heterogeneous datatype which impose
no restriction on the type of the elements.  This generality is not
needed for applications where all the elements are of the same type.
The use of Scheme vectors is not ideal for such applications because,
in the absence of a compiler with a fancy static analysis, the
representation will typically use some form of boxing of the elements
which means low space efficiency and slower access to the elements.
Moreover, homogeneous vectors are convenient for interfacing with
low-level libraries (e.g. binary block I/O) and to interface with
foreign languages which support homogeneous vectors.  Finally, the use
of homogeneous vectors allows certain errors to be caught earlier.

	<p></p>

This SRFI specifies a set of homogeneous vector datatypes which cover
the most practical cases, that is where the type of the elements is
numeric (exact integer or inexact real or complex) and the precision and
representation is efficiently implemented on the hardware of most
current computer architectures (8, 16, 32 and 64 bit integers, either
signed or unsigned, and 32 and 64 bit floating point numbers).

        <p></p>

This SRFI extends <a href="http://srfi.schemers.org/srfi-4/srfi-4.html">SRFI 4</a>
by providing the <code>u1vector</code>,
<code>c64vector</code>, and <code>c128vector</code> types, and
by providing analogues for most of the heterogeneous vector procedures
of <a href="https://srfi.schemers.org/srfi-133/srfi-133.html">
SRFI 133</a>.  There are additional procedures, many of which are
more or less closely analogous to the string procedures of SRFI 152.

<p>Note that there are no conversions between homogeneous vectors and strings in this SRFI.</p>

<H1>Specification</H1>

There are nine datatypes of exact integer homogeneous vectors (which will
be called integer vectors):

<TABLE>
<TR>
<TD><TD><STRONG>datatype</STRONG> <TD><STRONG>type of elements</STRONG>
</TR>
<TR>
<TD><TD><code>u1vector</code> <TD>unsigned exact integer in the range 0 to 1
</TR>
<TR>
<TD><TD><code>s8vector</code> <TD>signed exact integer in the range -2<sup>7</sup> to 2<sup>7</sup>-1
</TR>
<TR>
<TD><TD><code>u8vector</code> <TD>unsigned exact integer in the range 0 to 2<sup>8</sup>-1
</TR>
<TR>
<TD><TD><code>s16vector</code><TD>signed exact integer in the range -2<sup>15</sup> to 2<sup>15</sup>-1
</TR>
<TR>
<TD><TD><code>u16vector</code><TD>unsigned exact integer in the range 0 to 2<sup>16</sup>-1
</TR>
<TR>
<TD><TD><code>s32vector</code><TD>signed exact integer in the range -2<sup>31</sup> to 2<sup>31</sup>-1
</TR>
<TR>
<TD><TD><code>u32vector</code><TD>unsigned exact integer in the range 0 to 2<sup>32</sup>-1
</TR>
<TR>
<TD><TD><code>s64vector</code><TD>signed exact integer in the range -2<sup>63</sup> to 2<sup>63</sup>-1
</TR>
<TR>
<TD><TD><code>u64vector</code><TD>unsigned exact integer in the range 0 to 2<sup>64</sup>-1
</TR>
</TABLE>

	<p></p>

There are two datatypes of inexact real homogeneous vectors (which will
be called float vectors):

<TABLE>
<TR>
<TD><TD><STRONG>datatype</STRONG> <TD><STRONG>type of elements</STRONG>
</TR>
<TR>
<TD><TD><code>f32vector</code> <TD>inexact real
</TR>
<TR>
<TD><TD><code>f64vector</code> <TD>inexact real
</TR>
</TABLE>

	<p></p>

The only difference between the two float vector types is that
<code>f64vector</code>s preserve at least as much precision as
<code>f32vector</code>s (see the implementation section for details).

	<p></p>

And there are two datatypes of inexact complex homogeneous vectors (which will
be called complex vectors):

<TABLE>
<TR>
<TD><TD><STRONG>datatype</STRONG> <TD><STRONG>type of elements</STRONG>
</TR>
<TR>
<TD><TD><code>c64vector</code> <TD>inexact complex
</TR>
<TR>
<TD><TD><code>c128vector</code> <TD>inexact complex
</TR>
</TABLE>

	<p></p>

The only difference between the two complex vector types is that
<code>c128vector</code>s preserve at least as much precision as
<code>c64vector</code>s (see the implementation section for details).

	<p></p>

A Scheme system that conforms to this SRFI does not have to support
all of these homogeneous vector datatypes.  However, a Scheme system
must support float vectors if it
supports Scheme inexact reals (of any precision).  A Scheme system
must support complex vectors if it supports Scheme inexact complex numbers
(of any precision).  Finally, a Scheme system
must support a particular integer vector datatype if the system's
exact integer datatype contains all the values that can be stored in
such an integer vector.  Thus a Scheme system with bignum support must
implement all the integer vector datatypes, but a Scheme system might
only support <code>s8vector</code>s, <code>u8vector</code>s,
<code>s16vector</code>s and <code>u16vector</code>s if it only
supports integers in the range -2<sup>29</sup> to 2<sup>29</sup>-1 (which would
be the case if they are represented as 32-bit machine integers with a 2-bit tag).

        <p></p>

Scheme systems which conform to this SRFI and also conform to either R6RS or R7RS
must use the same datatype for bytevectors and for u8vectors.  All other homogeneous vector
types are disjoint from each other and from all other Scheme types.

	<p></p>

Each element of a homogeneous vector must be <i>valid</i>.  That is, for an
integer vector, it must be an exact integer within the
inclusive range specified above; for a float vector, it must be an
inexact real number; and for a complex vector, it must be an inexact
complex number.  It is an error to try to use a constructor or mutator
to set an element to an invalid value.

    <p>
      It should be noted that all of the procedures that iterate across
      multiple vectors in parallel stop iterating and produce the final
      result when the end of the shortest vector is reached.  The sole
      exception is <tt>@vector=</tt>, which
      automatically returns <tt>#f</tt> if the vectors' lengths vary.
    </p>


<H2>Notation</H2>

So as not to multiply the number of procedures described in this SRFI beyond necessity, a
special notational convention is used.  The description of the procedure
<code>make-@vector</code> is really shorthand for the descriptions of the thirteen
procedures <code>make-u1vector</code>, <code>make-s8vector</code>, ...
<code>make-c128vector</code>, all of which are exactly the same except that
they construct different homogeneous vector types.  Furthermore, except as
otherwise noted, the semantics of each procedure are those of the corresponding
SRFI 133 procedure, except that it is an error to attempt
to insert an invalid value into a homogeneous vector.
Consequently, only a brief description of each procedure is given, and
SRFI 133 (or in some cases SRFI 152) should be consulted for the details.

    <p>
      In the section containing specifications of procedures, the
      following notation is used to specify parameters and return
      values:
    </p>
    <dl>
      <dt><i>(f arg<sub>1</sub> arg<sub>2</sub> ...) -> something</i></dt> <dd>
        A procedure <tt><i>f</i></tt> that takes the parameters
        <tt><i>arg<sub>1</sub> arg<sub>2</sub>
        ...</i></tt> and returns a value of the
        type <tt><i>something</i></tt>.
        If two values are returned, two types are specified.
        If <tt><i>something</i></tt>
        is <tt>unspecified</tt>, then <tt><i>f</i></tt> returns a single
        implementation-dependent value; this SRFI does not specify what it
        returns, and in order to write portable code, the return value
        should be ignored.
        <br />
        <br />
      </dd>

      <dt><i>vec</i></dt>
      <dd>
        Must be a heterogeneous vector, i.e. it must
        satisfy the predicate <tt>vector?</tt>.
        <br />
        <br />
      </dd>

      <dt><i>@vec, @to, @from</i></dt>
      <dd>
        Must be a homogeneous vector, i.e. it must
        satisfy the predicate <tt>@vector?</tt>.
        In <tt>@vector-copy!</tt> and <tt>reverse-@vector-copy!</tt>,
        <i>@to</i> is the destination and <i>@from</i> is the source.
        <br />
        <br />
      </dd>

      <dt><i>i, j, start, at</i></dt>
      <dd>
        Must be an exact nonnegative integer less than the length of the @vector.
        In <i>@vector-copy!</i> and <i>reverse-@vector-copy!</i>,
        <i>at</i> refers to the destination and <i>start</i> to the source.
        <br />
        <br />
      </dd>

      <dt><i>end</i></dt>
      <dd>
        Must be an exact nonnegative integer not less than <i>start</i>.
        This indicates the index directly before
        which traversal will stop &mdash; processing will occur until
        the index of the vector is one less than <tt><i>end</i></tt>.  It is the
        open right side of a range.
        <br />
        <br />
      </dd>

      <dt><i>f</i></dt>
      <dd>
        Must be a procedure taking one or more
        arguments, which returns (except as noted otherwise) exactly one value.
        <br />
        <br />
      </dd>

      <dt><i>pred?</i></dt>
      <dd>
        Must be a procedure taking one or more
        arguments that returns one value, which is treated as a
        boolean.
        <br />
        <br />
      </dd>

      <dt><i>=</i></dt>
      <dd>
        Must be an equivalence procedure.
        <br />
        <br />
      </dd>

      <dt><i>
        obj, seed, knil
      </i></dt>
      <dd>
        Any Scheme object.
        <br />
        <br />
      </dd>

      <dt><i>
        fill, value
      </i></dt>
      <dd>
        Any number that is valid with respect to the <i>@vec</i>.
        <br />

        <br />
      </dd>

      <dt><i>[something]</i></dt>
      <dd>
        An optional argument; it needn't necessarily be applied.
        <tt><i>Something</i></tt> needn't necessarily be one thing; for
        example, this usage of it is perfectly valid:
        <br />
        <br />
        <code>
          &nbsp;&nbsp;&nbsp;[start [end]]
        </code>
        <br />
        <br />
        and is indeed used quite often.
        <br />
        <br />
      </dd>

      <dt><i>something ...</i></dt>
      <dd>
        Zero or more <tt><i>something</i></tt>s are
        allowed to be arguments.
        <br />
        <br />
      </dd>

      <dt><i>
        something<sub>1</sub> something<sub>2</sub>
        ...
      </i></dt>
      <dd>
        At least one <tt><i>something</i></tt> must be
        arguments.
        <br />
        <br />
      </dd>

    </dl>


<H2>Procedures</H2>

<p>The procedures shared with SRFI 4 are marked with [SRFI 4].
The procedures with the same semantics as SRFI 133 are marked with [SRFI 133]
unless they are already marked with [SRFI 4].
The procedures analogous to SRFI 152 string procedures are marked with [SRFI 152].

<H3>Constructors</H3>

<p><code>(make-@vector <i>size</i> [<i>fill</i>]) -> @vector </code> [SRFI 4]</p>

<p>Returns a @vector whose length is <i>size</i>.  If <i>fill</i> is provided,
all the elements of the @vector are initialized to it.</p>

<p><code>(@vector <i>value ...</i>) -> @vector </code> [SRFI 4]</p>

<p>Returns a @vector initialized with <i>values</i>.</p>

<p><code>(@vector-unfold <i>f length seed ...</i>) -> @vector</code> [SRFI 133]</p>

<p>Create a @vector whose length is <i>length</i> and initialize it by calling
f, f(f), f(f(f))) ... on the <i>seed</i>.</p>

<p><code>(@vector-unfold-right <i>f length seed ...</i>) -> @vector</code> [SRFI 133]</p>

<p>The same as <code>@vector-unfold</code>, but initializes the @vector from right to left.</p>

<p><code>(@vector-copy <i>@vec</i> [<i>start</i> [<i>end</i>]]) -> @vector</code> [SRFI 133]</p>

<p>Makes a copy of the portion of <i>@vec</i> from <i>start</i> to <i>end</i> and returns it.</p>

<p><code>(@vector-reverse-copy <i>@vec</i> [<i>start</i> [<i>end</i>]]) -> @vector</code> [SRFI 133]</p>

<p>The same as <code>@vector-copy</code>, but in reverse order.</p>

<p><code>(@vector-append <i>@vec ...</i>) -> @vector</code> [SRFI 133]</p>

<p>Returns a @vector containing all the elements of the <i>@vecs</i> in order.</p>

<p><code> (@vector-concatenate <i>list-of-@vectors</i>) -> @vector</code> [SRFI 133]</p>

<p>The same as <code>@vector-append</code>, but takes a list of @vectors rather than
multiple arguments.</p>

<p><code>(@vector-append-subvectors [<i>@vec start end] ...</i>) -> @vector</code> [SRFI 133]</p>

<p>Concatenates the result of applying <code>@vector-copy</code> to each triplet of
<i>@vec, start, end</i> arguments, but may be implemented more efficiently.</p>

<H3>Predicates</H3>

<p><code>(@? <i>obj</i>) -> boolean</code></p>

<p>Returns <code>#t</code> if <i>obj</i> is a valid element of an
@vector, and <code>#f</code> otherwise.</p>

<p><code>(@vector? <i>obj</i>) -> boolean</code> [SRFI 4]</p>

<p>Returns <code>#t</code> if <i>obj</i> is a @vector, and <code>#f</code>
otherwise.</p>

<p><code>(@vector-empty? <i>@vec</i>) -> boolean</code> [SRFI 133]</p>

Returns <code>#t</code> if <i>@vec</i> has a length of zero,
and <code>#f</code> otherwise.

<p><code>(@vector= <i>elt=? @vec ...</i>) -> boolean</code> [SRFI 133]</p>

<p>Compares the <i>@vecs</i> for elementwise equality, using
<i>elt=?</i> to do the comparisons.</p>

<H3>Selectors</H3>

<p><code>(@vector-ref <i>@vec i</i>) -> value</code> [SRFI 4]</p>

<p>Returns the <i>i</i>th element of <i>@vec</i>.</p>

<p><code>(@vector-length <i>@vec</i>) -> exact nonnegative integer</code> [SRFI 4]</p>

<p>Returns the length of <i>@vec</i></p>

<H3>Iteration</H3>

<p><code>(@vector-take <i>@vec n</i>) -> @vector</code>] [SRFI 152]</p>

<p><code>(@vector-take-right <i>@vec n</i>) -> @vector</code> [SRFI 152]</p>

<p>Returns a @vector containing the first/last <i>n</i>
elements of <i>@vec</i>.</p>

<p><code>(@vector-drop <i>@vec n</i>) -> @vector</code> [SRFI 152]</p>

<p><code>(@vector-drop-right <i>@vec n</i>) -> @vector</code> [SRFI 152]</p>

<p>Returns a @vector containing all except the first/last <i>n</i>
elements of <i>@vec</i>.</p>

<p><code>(@vector-split-at <i>@vec n</i>) -> @vector and @vector</code> [SRFI 152]</p>

<p>Returns two values, both @vectors.  The first is the result of
<code>(@vector-take <i>@vec n</i>)</code>, and the second is
the result of <code>(@vector-drop <i>@vec n</i>)</code>.</p>

<p><code>(@vector-segment <i>@vec n</i>) -> list</code> [SRFI 152]</p>

<p>Returns a list of @vectors, each of which contains <i>n</i>
consecutive elements of <i>@vec</i>.
The last @vector may be shorter than <i>n</i>.</p>

<p><code>(@vector-fold <i>kons knil @vec<sub>1</sub> @vec<sub>2</sub> ...</i>) -> object</code> [SRFI 133]</p>

<p><code>(@vector-fold-right <i>kons knil @vec<sub>1</sub> @vec<sub>2</sub> ...</i>) -> object</code> [SRFI 133]</p>

<p>Folds <i>kons</i> over the elements of <i>@vec</i> 
in increasing/decreasing order using <i>knil</i>
as the initial value.</p>

<p><code>(@vector-map <i>f @vec<sub>1</sub> @vec<sub>2</sub> ...</i>) -> @vector</code> [SRFI 133]</p>

<p><code>(@vector-map! <i>f @vec<sub>1</sub> @vec<sub>2</sub> ...</i>) -> unspecified</code> [SRFI 133]</p>

<p><code>(@vector-for-each <i>f @vec<sub>1</sub> @vec<sub>2</sub> ...</i>) -> unspecified</code> [SRFI 133]</p>

<p>Iterate over the elements of <i>@vec</i> and apply <i>f</i>
to each, returning respectively a @vector of the results,
an undefined value with the results placed back in <i>@vec</i>,
and an undefined value with no change to <i>@vec</i>.</p>

<p><code>(@vector-count <i>pred? @vec<sub>1</sub> @vec<sub>2</sub> ...</i>) -> exact nonnegative integer</code> [SRFI 133]</p>

Call <i>pred?</i> on the nth argument of each <i>@vec</i> and
return the number of calls that return true.</p>

<p><code>(@vector-cumulate <i>f knil @vec</i>) -> @vector</code> [SRFI 133]</p>

<p>Like <code>@vector-fold</code>, but returns an @vector of partial results
rather than just the final result.</p>

<H3>Searching</H3>

<p><code>(@vector-take-while <i>@vec pred?</i> -> index</code> [SRFI 152]</p>

<p><code>(@vector-take-while-right <i>@vec pred?</i> -> index</code> [SRFI 152]</p>

<p>Return the shortest prefix/suffix of <i>@vec</i> all of whose elements
satisfy <i>pred?</i>.

<p><code>(@vector-drop-while <i>@vec pred</i> -> index</code> [SRFI 152]</p>

<p><code>(@vector-drop-while-right <i>@vec pred</i> -> index</code> [SRFI 152]</p>

Drops the longest initial prefix/suffix of <i>@vec</i> such that all its
elements satisfy <i>pred</i>.</p>

<p><code>(@vector-index <i>pred? @vec.</i>) -> exact nonnegative integer or #f</code> [SRFI 133]</p>

<p><code>(@vector-index-right <i>pred? @vec.</i>) -> exact nonnegative integer or #f</code> [SRFI 133]</p>

<p>Return the index of the first/last element of <i>@vec</i> that
satisfies <i>pred?</i>.

<p><code>(@vector-skip <i>pred? @vec</i>) -> exact nonnegative integer or #f</code> [SRFI 133]</p>

<p><code>(@vector-skip-right <i>pred? @vec.</i>) -> exact nonnegative integer or #f</code> [SRFI 133]</p>

<p>Returns the index of the first/last element of <i>@vec</i> that
does not satisfy <i>pred?</i>.

<p><code>(@vector-binary-search <i>@vec value =</i>) -> exact nonnegative integer or #f</code> [SRFI 133]</p>

<p>Returns the index of any element of <i>@vec</i> that is the same as
<i>value</i> in the sense of the <i>=</i> argument using a binary search.
Returns <code>#f</code> if there is no such element.</p>

<p><code>(@vector-any <i>pred? @vec<sub>1</sub> @vec<sub>2</sub> ...</i>) -> value or #f</code> [SRFI 133]</p>

<p>Returns the first set of elements from the <i>@vecs</i> which
satisfy <i>pred?</i>, or <code>#f</code> if there is no such set.</p>

<p><code>(@vector-every <i>pred? @vec<sub>1</sub> @vec<sub>2</sub> ...</i>) -> value or #f</code> [SRFI 133]</p>

<p>If all sets of elements from the <i>@vecs</i> satisfy <i>pred?</i>,
return the last set.  If none do, return <code>#f</code>.</p>

<p><code>(@vector-partition <i>pred? @vec</i>) -> @vector and integer</code> [SRFI 133]</p>

<p>Returns a @vector of the same type as <i>@vec</i>, but with all elements
satisfying <i>pred?</i> in the leftmost part of the vector and the other
elements in the remaining part.  The order of elements is otherwise
preserved.  Returns two values, the new @vector and the number of 
elements satisfying <i>pred?</i>.</p>

<p><code>(@vector-filter <i>pred? @vec</i> -> @vector</code> [SRFI 152]</p>

<p><code>(@vector-remove <i>pred? @vec</i> -> @vector</code> [SRFI 152]</p>

<p>Return a @vector containing the elements of @vec that satisfy / do not satisfy
<i>pred?</i>.

<H3>Mutators</H3>

<p><code>(@vector-set! <i>@vec i value</i>) -> unspecified</code> [SRFI 4]</p>

<p>Sets the <i>i</i>th element of <i>@vec</i> to <i>value</i>.</p>

<p><code>(@vector-swap! <i>@vec i j</i>) -> unspecified</code> [SRFI 133]</p>

<p>Interchanges the <i>i</i>th and <i>j</i>th elements of <i>@vec</i>.</p>

<p><code>(@vector-fill! <i>@vec fill</i> [<i>start</i> [<i>end</i>]]) -> unspecified</code> [SRFI 133]</p>

<p>Fills the portion of <i>@vec</i> from <i>start</i> to <i>end</i>
with the value <i>fill</i>.</p>

<p><code>(@vector-reverse! <i>@vec</i> [<i>start</i> [<i>end</i>]]) -> unspecified</code> [SRFI 133]</p>

<p>Reverses the portion of <i>@vec</i> from <i>start</i> to <i>end</i>.</p>

<p><code>(@vector-copy! <i>@to at @from</i> [<i>start</i> [<i>end</i>]]) -> unspecified</code> [SRFI 133]</p>

<p>Copies the portion of <i>@from</i> from <i>start</i> to <i>end</i>
onto <i>@to</i>, starting at index <i>@at</i>.

<p><code>(@vector-reverse-copy! <i>@to at @from</i> [<i>start</i> [<i>end</i>]]) -> unspecified</code> [SRFI 133]</p>

<p>The same as <code>@vector-copy!</code>, but copies in reverse.</p>

<H3>Conversion</H3>

<p><code>(@vector->list <i>@vec</i> [<i>start</i> [<i>end</i>]]) -> proper-list</code> [SRFI 4]</p>

<p><code>(reverse-@vector->list <i>@vec</i> [<i>start</i> [<i>end</i>]]) -> proper-list</code> [SRFI 133]</p>

<p><code>(list->@vector <i>proper-list</i>) -> @vector</code> [SRFI 4]</p>

<p><code>(reverse-list->@vector <i>proper-list</i>) -> @vector</code> [SRFI 133]</p>

<p><code>(@vector->vector <i>@vec</i>) -> vector</code></p>

<p><code>(vector->@vector <i>vec</i>) -> @vector</code></p>


<p>Returns a list, @vector, or heterogeneous vector with the same
elements as the argument, in reverse order where specified.</p>

<H3>Output</H3>

<p><code>(write-@vector <i>vec</i> [ <i>port</i> ] -> unspecified</code></p>

<p>Prints to <i>port</i> (the current output port by default) a representation of
<i>@vec</i> in the lexical syntax explained below.</p>

<H2>Optional lexical syntax</H2>

Each homogeneous vector datatype has an external representation which
may be supported by the <code>read</code> and <code>write</code>
procedures and by the program parser.
Conformance to this SRFI does not in itself require support for these
external representations.

	<p></p>

For each value of <code>@</code> in {
<code>u1</code>,
<code>s8</code>, <code>u8</code>,
<code>s16</code>, <code>u16</code>,
<code>s32</code>, <code>u32</code>,
<code>s64</code>, <code>u64</code>,
<code>f32</code>, <code>f64</code>,
<code>c64</code>, <code>c128</code>
}, if the datatype <code>@vector</code> is supported, then
the external representation of instances of the datatype
<code>@vector</code> is <code>#@(</code> ...elements... <code>)</code>.

	<p></p>

For example, <code>#u8(0 #e1e2 #xff)</code> is a
<code>u8vector</code> of length 3 containing 0, 100 and 255;
<code>#f64(-1.5)</code> is an <code>f64vector</code> of length 1
containing -1.5.

	<p></p>

Note that the syntax for float vectors conflicts with R5RS,
which parses <code>#f32()</code> as 3 objects: <code>#f</code>,
<code>32</code> and <code>()</code>.  For this reason, conformance to
this SRFI implies this minor nonconformance to R5RS.

	<p></p>

This external representation is also available in program source code.
For example, <code>(set! x '#u8(1 2 3))</code> will set <code>x</code>
to the object <code>#u8(1 2 3)</code>.  Literal homogeneous vectors,
like heterogeneous vectors, are self-evaluating; they do not need to be quoted.
Homogeneous vectors can appear in quasiquotations but must not contain
<code>unquote</code> or <code>unquote-splicing</code> forms
(i.e. <code>`(,x #u8(1 2))</code> is legal but <code>`#u8(1 ,x
2)</code> is not).  This restriction is to accommodate the many Scheme
systems that use the <code>read</code> procedure to parse programs.

<H2>Packaging</H2>

<p>This SRFI is packaged as thirteen libraries named <code>(srfi
160 @)</code>, or <code>(srfi :160 @)</code> in R6RS systems, on the
assumption that most programs will use only a few homogeneous vector
types.  There is also a SRFI 4 library named <code>(srfi 4)</code>,
or <code>(srfi :4)</code> in R6RS systems, which implements SRFI 4
on top of R6RS bytevectors.  Lastly, a <code>(r6rs bytevector)</code>
library is provided for R7RS systems;
it exports the same identifiers with the same meanings as the R6RS
standard library <code>(rnrs bytevectors (6))</code>, except that
because that library's definition of <code>bytevector-copy!</code>
conflicts with R7RS, it is exported as <code>r6rs:bytevector-copy!</code>.
This is the same convention that Larceny uses.</p>

<H1>Implementation</H1>

<p>The homogeneous vector datatypes described here suggest a concrete
implementation as a sequence of 8-, 16-, 32- or 64-bit elements, using
two's complement representation for the signed exact integers, and
single and double precision IEEE-754 floating point representation for
the inexact reals.  Although this is a practical implementation on
essentially all current architectures, a different implementation is
possible for machines which don't support these concrete numeric types.</p>

<p>The sample implementation, which is (not yet) in the repository of this SRFI,
is constructed in three layers.</p> 

<h2>Bytevector library layer</h2>

<p> The lowest layer is a portable
implementation of the R6RS bytevector library.  So that it can be
run and tested on R6RS systems, it is named <code>(r6rs bytevectors)</code>
rather than <code>(rnrs bytevectors (6))</code>.
If a native R6RS library is available, it is likely to be much more
performant and should be used instead.  In particular, the
string conversions can be implemented much more efficiently in a
low-level language such as C.</p>


<p>The following files are provided for this layer:</p>

<ul>
<li><code>include</code> - an R6RS library for file inclusion
</li>

<li><code>r6rs.bytevectors.scm</code> - Chicken 4 library.
</li>

<li><code>r6rs/bytevectors.scm</code> - Guile library.
</li>

<li><code>r6rs/bytevectors.sld</code> - Chibi library.
Can be adapted to any R7RS system.</li>

<li><code>r6rs/bytevectors-impl.scm</code> - Shared implementation.
Can be adapted to any R5RS system that provides the primitive bytevector
procedures <code>make-bytevector</code>, <code>bytevector?</code>,
<code>bytevector-length</code>,
<code>bytevector-u8-ref</code>, and <code>bytevector-u8-set!</code>.
In Chicken these are simulated with u8vectors from the native SRFI 4
implementation.</li>

<li><code>r6rs/srfi-56-ieee-impl.scm</code> - Implementation of native IEEE procedures
from SRFI 56.  Currently not working and unused,
so Chibi does not correctly support IEEE operations.</li>

<li><code>r6rs/chicken-ieee.scm</code> - Chicken implementation of native IEEE procedures
in mixed Scheme and C.</li>

<li><code>r6rs/r7rs-shim.scm</code> - R7RS shim.
Provides the R7RS procedures <code>bytevector-copy</code>,
<code>bytevector-copy!</code>, <code>utf8->string</code>,
and <code>string->utf8</code>, plus a trivial implementation
of <code>r6rs:bytevector-copy</code>.  These can be used by
any R5RS system.</li>

<li><code>r6rs/shared-test.scm</code> - Shared tests (no dependencies).</li>

<li><code>r6rs/chicken-test.scm</code> - Chicken test script wrapper.
</li>

<li><code>r6rs/guile-tests.scm</code> - Guile test script wrapper.
</li>

<li><code>r6rs/r7rs-tests.scm</code> - Chibi test script wrapper.
</li>

<li><code>r6rs/r6rs-tests.scm</code> - Native R6RS library test script wrapper.
</li>
</ul>

<p>This layer requires implementations of <code>bitwise-and</code>,
<code>bitwise-ior</code>, <code>arithmetic-shift</code>, and
<code>bit-field</code> from SRFI 152,which provides portable but very slow implementations
of all of these.  If native implementations are available, they should be used instead.</p>

<p>Also required are implementations of the four native IEEE procedures.  These are
trivial to do in (non-portable) C for each implementation, and very difficult to do
both portably and accurately in Scheme.</p>

<h2>SRFI-4 layer</h2>

<p>The second layer consists of two SRFI 4 implementations plus analogues of SRFI 4
for u1vectors and complex vectors.
One implementation is layered on top of <code>(rnrs bytevectors)</code>
or <code>(r6rs bytevectors)</code>, and should be used if the implementation provides
primitive bytevectors.  The second implementation is layered on top of plain Scheme
vectors.  Both implementations require either SRFI 9, R6RS record types,
or R7RS record types.</p>

<p>If a native SRFI 4 implementation is available, it should be used instead of the
implementation at this layer.  However, the SRFI 4 analogues for u1vectors and
complex vectors will still be required.

<p>The following files are provided for this layer:</p>

<ul>
<li><code>srfi/4-impl.scm</code> - implementation of SRFI 4 procedures
using bytevector library.</li>

<li><code>srfi/4-vec.scm</code> - implementation of SRFI 4 procedures
using heterogeneous vectors.</li>

<li><code>srfi/4-macros.scm</code> - macros used by this layer.

<li><code>srfi/4.sld</code> - R7RS library for SRFI 4.</li>

<li><code>srfi/%3a4.sls</code> - R6RS library for SRFI 4.</li>

<li><code>srfi/bitvectors.scm</code> - SRFI-4-like implementation of u1vectors using u8vectors.</li>

<li><code>srfi/cvectors.scm</code> - SRFI-4-like implementation of complex vectors using float vectors.</li>

<li><code>srfi/chicken4-64.scm</code> - implementation of {s64,u64}vectors for Chicken 4.</li>

</ul>

<h2>SRFI 160 layer</h2>

<p>The third layer is SRFI 160 itself.</p>

<p>The following files are provided for this layer:</p>

<ul>
<li><code>srfi.160.at.scm</code> - Chicken libraries on top of native Chicken SRFI 4</li>

<li><code>srfi/%3a160/at.scm</code> - Guile libraries on top of native Guile SRFI 4.
Can be adapted to any R6RS system that provides <code>include</code>.</li>

<li><code>srfi/160/at.scm</code> - Chibi libraries on top of SRFI 4.
Can be adapted to any R7RS system.</li>

<li><code>srfi/160/at-impl.scm</code> - Shared implementation of non-SRFI 4 procedures.</li>

<li><code>atexpander.sh</code> - a trivial shell script using <code>sed</code>
to expand files into their variants</li>
</ul>


<p>The sample implementation uses little-endian representations of
all homogeneous vector types (but it is easy to change to big-endian representation
if desired).  Float vectors use IEEE 32-bit and 64-bit binary floats;
complex vectors use two consecutive floats with the real part first and the imaginary part second.
It is assumed that 64-bit integers are representable in the
underlying Scheme implementation, which typically is only true if the
Scheme has bignums.

<H1>Copyright</H1>
Copyright &copy; John Cowan 2018.
<p>
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
</p>
<p>
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</p>
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p>


<hr>
<address>Editor: <a href="mailto:srfi minus editors at srfi dot schemers dot org">
  Arthur A. Gleckler</a></address>

  </body>
</html>
